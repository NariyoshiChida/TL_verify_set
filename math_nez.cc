#include<bits/stdc++.h>
// The following is generated by the Nez Grammar Generator 
#include"pegtl.hh"

#define REP(i,s,n) for(int i=s;i<n;i++)
#define rep(i,n) REP(i,0,n)

using namespace std;

/*
  ./a.out '式'
  or
  ./a.out ファイル名
  ただしファイル名の拡張子は in とすること 
  例: 1.in
      00_small_00.in
  
  何も出力されなければ成功
  失敗した場合は assert にひっかかるので Runtime Error
 */

/*
  修正点
  struct pExpr : 
  pSum {};

  ->

  struct pExpr : 
  pegtl::must<pSum,pegtl::success> {};

  -- seq等で囲まなければならない
  
  あと、謎の括弧が入っていたので削除
 */

// パースの過程を出力
const bool DEBUG = false;

struct pFile;
struct pExpr;
struct pSum;
struct pProduct;
struct pValue;
struct pFile : 
   pegtl::seq<pExpr,pegtl::star<pegtl::any>> {};
struct pExpr : 
  pegtl::seq<pSum,pegtl::success> {};
struct pSum : 
   pegtl::seq<pProduct,pegtl::star<pegtl::seq<pegtl::success,pegtl::sor<pegtl::seq<pegtl::one<43>,pegtl::success>,pegtl::seq<pegtl::one<45>,pegtl::success>>,pProduct,pegtl::success>>> {};
struct pProduct : 
   pegtl::seq<pValue,pegtl::star<pegtl::seq<pegtl::success,pegtl::sor<pegtl::seq<pegtl::one<42>,pegtl::success>,pegtl::seq<pegtl::one<47>,pegtl::success>,pegtl::seq<pegtl::one<37>,pegtl::success>>,pValue,pegtl::success>>> {};
struct pValue : 
  pegtl::seq<pegtl::sor<pegtl::seq<pegtl::success,pegtl::plus<pegtl::one<48,49,50,51,52,53,54,55,56,57>>,pegtl::success,pegtl::success>,pegtl::seq<pegtl::one<40>,pExpr,pegtl::one<41>>>> {};

template<typename T>
struct action : pegtl::nothing<T> {};

template<>
struct action<pValue> {
  static void apply(const pegtl::input& in,std::string &s){
    if( in.string()[0] != '(' ) s += in.string();
    if( DEBUG ) cout << "value : accept " << in.string() << endl;
  }
};

template<>
struct action<pegtl::one<'+'>> {
  static void apply(const pegtl::input& in,std::string &s){
    s += in.string();    
    if( DEBUG ) cout << "+ : accept " << in.string() << endl;
  }
};

template<>
struct action<pegtl::one<'-'>> {
  static void apply(const pegtl::input& in,std::string &s){
    s += in.string();
    if( DEBUG ) cout << "- : accept " << in.string() << endl;
  }
};

template<>
struct action<pegtl::one<'*'>> {
  static void apply(const pegtl::input& in,std::string &s){
    s += in.string();
    if( DEBUG ) cout << "* : accept " << in.string() << endl;
  }
};

template<>
struct action<pegtl::one<'/'>> {
  static void apply(const pegtl::input& in,std::string &s){
    s += in.string();
    if( DEBUG ) cout << "/ : accept " << in.string() << endl;
  }
};
                         
template<>
struct action<pegtl::one<'('>> {
  static void apply(const pegtl::input& in,std::string &s){
    s += in.string();
    if( DEBUG ) cout << "( : accept " << in.string() << endl;
  }
};

template<>
struct action<pegtl::one<')'>> {
  static void apply(const pegtl::input& in,std::string& s){
    s += in.string();
    if( DEBUG ) cout << ") : accept " << in.string() << endl;
  }
};

int main(int argc,char* argv[]){
  if( argc > 1 ) {
    std::string arg = std::string(argv[1]);
    bool command = true;
    if( arg.size() >= 3 && arg.substr((int)arg.size()-3) == ".in" ) command = false;

    if( command ) {
      std::string input_text=std::string(argv[1]);
      std::string accepted_text="";
      pegtl::parse<pFile,action>(1,argv,accepted_text);

      //cout << accepted_text << endl;
      // 入力した値と受理した値が異なる場合、パース失敗
      assert( accepted_text == input_text );
    } else {
      freopen(argv[1],"r",stdin);
      std::string input_text;
      std::string accepted_text="";
      cin >> input_text;
      pegtl::parse<pFile,action>(input_text,"",accepted_text);
      // 入力した値と受理した値が異なる場合、パース失敗

      //cout << accepted_text << endl;
      assert( accepted_text == input_text );
    }
  } else cout << "no input" << endl;

  return 0;
}
